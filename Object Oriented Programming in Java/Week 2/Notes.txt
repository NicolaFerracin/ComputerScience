Object Oriented Programming in Java
Week 2

---------------------------

OOP: match the program to the problem we are solving.
Specifically on the map project, examples of objects that match well are:
Map - Shape - Location - Window - Color

Class is a type of data - custom data type that we get to define
Object is a piece of the Class data

---------------------------

Define Class Location

public class SimpleLocation {
	// Member variables, data the ojects store
	// outside any method, inside the class declaration
	public double latitude;
	public double longitude;

	// method
	// constructor. special method to create a new object
	// no return type, and the next word is the name of the class -> this makes the method a constructor
	public SimpleLocation(double lat, double lon) {
		this.latitude = lat;
		this.longitude = lon;
	}

	// another method
	public double distance(SimpleLocation other) {
	...
	}
}
---
// Create a new object of type SimpleLocation
SimpleLocation randomLoc1 = new SimpleLocation(115, -200);
SimpleLocation randomLoc2 = new SimpleLocation(115, -200);

// access method
randomLoc1.distance(randomLoc2);

---------------------------

Overloading Methods

ALERT: you can't overload a method with a different return type

What if we want to create a location without passing a latitude and a longitude?
Use Method overloading to create a new type of constructor for when no parameter is passed in

What if we want to misure the distance from one object to a different location without having
to create a new SimpleLocation object?
Method overloading of the distance method!

public class SimpleLocation {
	public double latitude;
	public double longitude;

	// Method Overload, if no parameter, we use default ones
	// DEFAULT CONSTRUCTOR: when no parameter is involved
	public SimpleLocation() {
		this.latitude = 32.9;
		this.longitude = -117.2
	}

	public SimpleLocation(double lat, double lon) {
		this.latitude = lat;
		this.longitude = lon;
	}

	// method overload of the distance method to allow user to get the distance
	// from a SimpleLocation to another location without having to create a new SimpleLocation
	public double distance(double otherLat, double otherLon) {
		...
	}

	public double distance(SimpleLocation other) {
		...
	}
}

---------------------------

PUBLIC VS PRIVATE
and protecting your data inside your classes

PUBLIC
public class SimpleLocation {
	// public means that anyone can access these object variables/methods
	// both for getting them and setting them
	public double latitude;
	public double longitude;
	public double distance(SimpleLocation other) {
		...
	}
}

SimpleLocation loc1 = new SimpleLocation(20, 30);
SimpleLocation loc2 = new SimpleLocation(-20, -30);
loc1.latitude = 50; -> THIS IS OK, because the variable is public so it's accessible outside
loc1.distance(loc2) -> THIS IS OK, because the method is public so it's accessible outside

----------

PRIVATE
public class SimpleLocation {
	// private means that they can get accessed only within the class I'm defining
	// and not outside
	private double latitude;
	private double longitude;
	private double distance(SimpleLocation other) {
		...
	}
}

SimpleLocation loc1 = new SimpleLocation(20, 30);
SimpleLocation loc2 = new SimpleLocation(-20, -30);
loc1.latitude = 50; -> ERROR, because the variable is private so it's NOT accessible outside
loc1.distance(loc2) -> ERROR, because the method is private so it's NOT accessible outside

RULE OF THUMB:
Make member variables PRIVATE

But we still want some liberty to get some info on our object -> user getters and setters

---------------------------

GETTER and SETTER
Why? They give us more control

public class SimpleLocation {
	private double latitude;
	private double longitude;

	// getter
	public double getLatitude() {
		return this.latitude;
	}

	// setter -> DO NOT USE if we didn't want the user to be able to change
	public double setLatitude(double lat) {
		this.latitude = lat;
	}
}


SimpleLocation loc1 = new SimpleLocation(20, 30);
System.out.println(loc1.latitude) -> ERROR!
System.out.println(loc1.getLatitude()) -> IT WORKS!

---------------------------

MEMORY MODELS
# stores the value 52 in a memory slot labeled var1
int var1 = 52;


SimpleLocation ucsd
# The object ucsd is created in the heap at a specific location unknown to us (i.e. @34)
# Java then populates a memory slot with the address @34 inside a memory slot labeled ucsd
# but it doesn't store the object data directly into the memory slot, only the reference to
# the address is stored
ucsd = new SimpleLocation(32.9, -117.2)
# the object's variables (latitude, longitude) are also stored in the heap, in the same way as
# var1 is stored in a memory slot, so with a value labeled with the variable name

---------------------------

SCOPE

ALERT: arrays and objects are NOT primitive types of data and their values
are stored in the heap and referenced from the variables storing them in memory
example:
# array of doubles to store coords; stored in the heap
double[] coords = {52, 10};
# example of ArrayLoc object that gets instantiated using the coords array; both stored in the heap
# basically the coords inside variable loc1 are a reference to the coords variable
ArrayLoc loc1 = new ArrayLoc(coords);
System.out.println(a.coords[0]); -> prints 52
# we update the coords array which is also referenced by the local coords inside loc1
# so we also affect them
coords[0] = 15;
System.out.println(a.coords[0]); -> prints 15
